2.7 Casts(Приведение типов)

в С++ есть 5 способов приведения типа.

2.7.1 Static cast 

Приведение на случай, когда не знаете какой тип нам нужен. Приведение в человеческом типе. stati_cast - создание новой сущности из старой.
Это функция как бы берет объект старого типа и возвращает объект нового типа. Он работает по правилам, которые существуют между типами.
Это самое классическое создание одного типа из другого. 

2.7.2 Reinterpret cast

Есть мягкая и жесткая форма. Мягкую, которую иногда можно использовать, жесткая когда очень-очень редко
Позволяет трактовать(реинтерпретировать) байты одного типа в памяти, как байты другого типа. 

static_cast - не работает мужду указателями

Но с указателями лучше не делать, потому что это ub. Reinterpret_cast можно использовать, когда функция возвращает void*, а мы хотим 
интерпертировать это как указатель на правильный тип. 

Жесткая форма - это cast к ссылке. 

2.7.3 Const cast 

static_cast - делает все по правилам, подстраховывает нас от нас самих
reinterpret_cast - обходит защиту и позволяет любые типы к любым другим, кроме константных
const_cast - это рецепт на случай нарушения костантности. При кастование неконстанты к константее будет ub.
Если хочется использовать const_cast в коде, то вы с вероятность 99% неправы. Логика работы программы работает странно.
Данный каст нарушает самые базовые запреты. Есть пару экзотических случаев.
Но пока что не стоит об этом думать

2.7.4 C-style cast
Он освмещает в себе всю мощь предыдщуих кастов. Он самый опасный в с++. Он пробует все касты подряд, пока не сработает.
Сначала const_cast, затем static cast, после const_cast, поверх которого static_cast. Если не работает, то дальше reinterpret_cast
и последний шаг reinterpret_cast поверх которого const cast. Если ничего не получилось, то ce. Но в ходе выполнения такого кастование
трудно понять, что было скастовано. 