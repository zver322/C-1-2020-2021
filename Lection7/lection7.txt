2.7 Casts(Приведение типов)

в С++ есть 5 способов приведения типа.

2.7.1 Static cast 

Приведение на случай, когда не знаете какой тип нам нужен. Приведение в человеческом типе. stati_cast - создание новой сущности из старой.
Это функция как бы берет объект старого типа и возвращает объект нового типа. Он работает по правилам, которые существуют между типами.
Это самое классическое создание одного типа из другого. 

2.7.2 Reinterpret cast

Есть мягкая и жесткая форма. Мягкую, которую иногда можно использовать, жесткая когда очень-очень редко
Позволяет трактовать(реинтерпретировать) байты одного типа в памяти, как байты другого типа. 

static_cast - не работает мужду указателями

Но с указателями лучше не делать, потому что это ub. Reinterpret_cast можно использовать, когда функция возвращает void*, а мы хотим 
интерпертировать это как указатель на правильный тип. 

Жесткая форма - это cast к ссылке. 

2.7.3 Const cast 

static_cast - делает все по правилам, подстраховывает нас от нас самих
reinterpret_cast - обходит защиту и позволяет любые типы к любым другим, кроме константных
const_cast - это рецепт на случай нарушения костантности. При кастование неконстанты к константее будет ub.
Если хочется использовать const_cast в коде, то вы с вероятность 99% неправы. Логика работы программы работает странно.
Данный каст нарушает самые базовые запреты. Есть пару экзотических случаев.
Но пока что не стоит об этом думать

2.7.4 C-style cast
Он освмещает в себе всю мощь предыдщуих кастов. Он самый опасный в с++. Он пробует все касты подряд, пока не сработает.
Сначала const_cast, затем static cast, после const_cast, поверх которого static_cast. Если не работает, то дальше reinterpret_cast
и последний шаг reinterpret_cast поверх которого const cast. Если ничего не получилось, то ce. Но в ходе выполнения такого кастование
трудно понять, что было скастовано. 

3. Классы и структуры. Инкапсуляция.

3.1 Идея ООП. Класс и струкутра, инкапсуляция.

Можно определять свои типы со своими операциями. Переход к ООП - это создание собственных типов, а затем выполнение операций над ними.

Создание типа - определить свой клас или свою структуру. 
Объекты не могут занимать 0 байт, поэтому пустой класс и пустая структура занимает 1 байт. Объекты занимают только целое число байт.
У классов есть поля и методы. Поля - это данные, которые хранятся в объекте этого типа. Операции - это действия, которые можно выполнять
над данынм объектом. 

В целях производительности к объектам добавляется padding, если в структуре число байт больше 8, но не кратно 8, то он добавляет до 8,
чтобы памяти было удобно располагать их по машинным словам. Методы можно перегружать

Инкапсуляция - это такой принцип, согласно которому, во-первых вы объявляете рядом данные и методы обработки  этих данных, во-вторых 
вы ограничиваете доступ к самим данным и открываете доступ извне лишь разрешенным способам обработки. Классически пример, реальньная
микроволновка, у которой есть ограниченное количество кнопок, которое делает что-то определенное. У нее есть ограниченный доступный функ-
ционал, который контролирует, что вы делаете, то что ничего не сломает. Внутри есть функции и возможности, которые незадукоментированы и 
вшиты внутрь, к которым нет доступа. 

Когда мы пишем классы, мы хотим, чтобы пользователь имел доступ к ограниченному набору методов, но не к полям и не к возможно некоторым методам
, которые для внутреннего использования. 

Private и public - модификаторы доступа, которые позволяют такое сделать. 

private часть позволяет менять и химияить внутри нее, не влияя на программу. Только поддерживать, что находится в public. 
В чем разница меду классами и структурами, в том, что в классе если ничего не писать, то все будет private, а в структуре public.
Модификаторы доступа можно писать в любоа порядке, чередую как угодно между собой. На это нет никакого ограничения. 

Перегрузка выполняется, до того как проверяется проверка доступа. Изначально нет private и public. Наш код изначально компилируется без них.
Лишь в конце проверяется правоверность доступа. Модификаторы доступа - это просто проверка в самый последний момент. Это доп. защита.
Перегрузка живет сама по себе. 

Методы можно определять вне класс, если они были объявленв внутри класса.

3.2 Конструкторы и деструкторы.

Конструктор, который не принимает аргументов, нызывается конструктором по умолчанию. Если нет конструкторов, то создается конструктор
по умолчанию.

По заврещению программы все автоматически выключается и зачищается, но если бы у нас в самой программе создавалось много строк, которые бы
динамически выделяли память, то память бы вся заполнилась. Поэтому нужно использовать деструктор, который будет это делать.

Десрутор нельязя перегружать, у него нет параметров. В десруторе нужно написать, что надо сделать после удаления объекта. 

Прежде чем объекту уничтожается и снимаетя со стека, то вызывается деструктор. В деструкторе надо делать только нетривиальные действия.
Освобождение памяти. Не надо писать, что sz=0, потому что данная переменная будет снята со стека вместе с объектом. Мы же не обнуляем 
локальные переменные при выходе из области выдимости. Это глупо и бессмысленно.  
Конструктор и деструктор можно определять вне класса. 

Методы одного класса нельзя определять в методах другого класса. Но внутри класса можно определить дугой класс. 