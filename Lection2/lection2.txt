1.3 Виды ошибок и неопределенное поведение (UB)

CE (compilation error, compile-time error) - код оказался некоректным с точки зрения 
компиляции.
Примеры: 
1)не точки запятой
2)использование необъявленной переменной
3)повтореное определение переменной в той же области видимости
4)x++ = b + a

Лексические ошибки

(std) (::) (cout) (<<) (x) (;)
Мы набираем в токен по сиволу пока это осмысленно. std - токен, std: - не токен
Токен(token)

Синтаксические ошибки
Пропуск точки запятой

Семантические ошибки
Чаще вссего будут встречаться на практике. 

Отличие error от fatal error, что  первом случае мы пойдем компилировать код дальше, а 
во втором компиляция прерывается.

Разные объекты поддерживают разные опреации.

Ошибками компиляции случаются не тольк из-за неправильного синтаксиса,
но и из-за того, что мы пытаемся вызвать операции , которые не поддержиаются 
объектом.

1) Выозов опреации над объектами, которая не поддерживается над типами этиъ объектов.
2) Образение к имени,которое не объявлено
3) Неоднозначное обращение к имени.

RE (runtime errors)
1) Слишком далекий выход за границу массива. 
2) Бесконечная рекурсия
3) Деление на 0??
1 и 2 - это segmentation fault. Это ситуация, когда программа обращается к участку памяти,
к которому она не имеет парва обращаться.
Также примерами являются exeptions, illegal instruction (core dumped). 

UB (undefined behaviour) - компилятор перестает гарантировать, что-то с исполнением кода.
Компилятор будет делать все что угодно.

С++ не запрещается выходить не очень далеко за пределы массива. Он просто выведет информацию 
из другой ячейки памяти.

С точки зрения компилятора, код - это входные данные, которые надо преобразовать
в выходные данные. Условие задачи - это тот файл с 1500 страницами. Если программа
содержит вещи, которых нет в стандарте. Компилятор перестает делать что-то разумное.
Компилятор действует, что данные корректные
Примеры:
1) Выход за преедлы массива
2) Переполнение int

g++ -O2 --std=c++17 test1.cpp - данный параметр используетя для оптимизации кода (0 - 3 - параметры)
При использовании такой шутки на код 
int main(){
    for(int i = 0; i < 300; ++i)
    std::cout << i << " " << i * 12345678 << std::endl;
}

Произошел бесконечнй цикл. Оптимизация может привести к интересным ошибкам. i никогда
не превосходит 173, поэтому усовие i < 300 - true. Компилятор экономит на сравнении по 
каждой итерации цикла.

Если по началау компилтор к чему-то придерается, то это хорошо. Потому что когда-то 
подобная ошибка стоила кому-то большой боли. Если компилчтор чего-то не заметил,
то в runtime будет что-то непредвиденное. Не все можно предвидеть на этапе компиляции.
Почему re не внести в стандарт. В питоне и дажва так. Так как это с++, то тут важна
эффекстивность. Поэтому тут нет такого. Елси бы это внесли в стандарт, то упала бы 
эффекстивность. Так как мы напрямую обращаемся к памяти, то поэтому мы в два раза выигрываем
в скорости. И если каждое обращение к массиву будет сопровождать проверкой на не выход за него.
То так бы много потеряли. 

В Java и Python вас подстраховывают. Из-за ub C++ выигрывает в эффективности.

Нет кучи доп проверок, которе нас подстраховывают.

Unspecified behaviour.
f() + g();
f(g(), h());

Если мы хотим, чтобы все предупреждения трактовались, как ошибки компиляции, то можно указать 
clang++ -Werror --std=c++17 test1.cpp - компиляций не произойдет.
g++  -O2 -Wall --std=c++17 test1.cpp - тогда появится warnings, которых не было
g++  -O2 -Wall -Wextra --std=c++17 test1.cpp - еще больший список предупреждений
g++  -O2 -Werror -Wall -Wextra --std=c++17 test1.cpp - будет жаловаться прям на все
Это поможет максимально перестраховаться от ub, поэтому стоит по началу 
использовать, да и в принципе всегда, чтобы учиться и делать код лучше

1.4 Declarations, definitions and scopes.

Программа - это последовательность объявлений. 

Объявление:
type id [= init];
type f_id(type id1, ..., type idn);
struct S;
class C;
namespace N {}

typedef shortname long_type_name;
typedef vvi vector<vector<int>>; (alias - псевдоним)

int x; - при объявлении переменной вы ее также определяете, конечно значение будет рандомным,
но тем немене вы ее определили

Объявление функции говорит, что такая функция существует и отныне ее можно использовать в коде.
А определение можно дать позже.

One defenition rule - кадая переменная и функция должна быть поределена ровно один раз.
Но объявлять можно сколько угодно раз.