1.6 Expressions and operators.

a + b;
f();
v.size();
++b;
a ? b : c

Очень большая тема, в данно йлекции будут затронуты базовые части

Arithmetical operators.
+ - * / %
Bitwise operators. (Нужны целые числа и возвращаются целые числа)
& | ~ ^ << >> 
Logical operators (Нужен bool и возвращается bool)
&& || !

&& - если слева находится flase, то правый не будет вычисляться. Если только
слева стоит true, только тогда будет вычисленно правая часть.

Это оператор как || правую часть не вычисляет, если по правой все понятно.

if (i < v.size() && v[i] == 0) - это гарантирует нам, что мы не получим ub
при выходе за массив.

=============================================================================

Comparison operators.
== != < > <= >=

=============================================================================

Increment and decrement
++a a++

++a - увеличивает на единицу и возвращает получившееся (эффективнее, потому что не требует
копирования) lvalue
a++ - увеличивает на единицу, но возвращает то, что было. rvalue

=============================================================================

Assignment and compound assignment (right-to-left, lvalue)
=
+= -= *= /= %= &= |= ^= <<= >>=
a *= b (эффективнее)
a = a + b

a = b; - возвращает то, что получилось (правоассоциативны)
a = b = c; (сначала b присовете с, потом a присвоете то, что получилось)
a += b *= c (так тоже можно)

=============================================================================

Operator sizeof.
sizeof - размер в байтах той или иной вещи. rvalue
int x = 0;
sizeof(x++) - размер x в байтах, значение x не изменится
Елси делать sizeof от вектора, то он вернет суммарное значение его четырех полей и это
будет константой. Он не вернет размер массива вектора.
vector<int> v(100);
sizeof(v);

=============================================================================

Ternary operator. lvalue or rvalue
condition ? a : b; Если true, то вычисляется а и возвращается. Иначе вычисляется b и
возвращается. Также как и с логическими операторами, есил одно было вычислено, то
другое не вычислется.

cout << (condition ? 1 : 0)
x = (condition ? a : b)
(condition ? x : y) = 0 - если только в зависимости от условия, что-то одно из двух будет
приравнено к нулю.

=============================================================================

Operator comma. lvalue or rvalue
a, b; - вычисляет левую часть, потому правую часть. Затема возвращащет, что получилось
в правой части. Он никак не соотносит левую и правую часть
a = b, c = d, ++x, ++y; - вернет то, что справа.
x = (a = b, ++y, ++b); - присвоится, что получится при ++b
(a = b, c = d) = x; c присвоется x

Оператор запятая не будет трогать правую часть пока не вычилет левую. 
Самый низкоприоритетный оператор.

Operetor precedence: https://en.cppreference.com/w/cpp/language/operator_precedence

Левоассоциативность. Не говорит нам в каком порядке будет вычисляться выражение. Оно говорит
как в выражении будут расставлены скобки, но не говорит о том, как будут вычислены сами части
выражения.

Order of evaluation: https://en.cppreference.com/w/cpp/language/eval_order

Порядок вычисления параметров функции не регламентирован.

Concepts of lvalue and rvalue.
(a, b) = x;
a + b = x;
lvalue - интуитивно это к чему можно присваивать. Формально по-другому. И неформально не совсем 
верно.

II. Compound types.

2.1 Pointers and kinds of memory.

Для работы с адресами мы используем указатели

int* p- тип, хранящий адрес памяти под которые лежит int. предсавляет собой целое число. 
Поддерживает другие операции

*: T* -> T; - унарная операция. (dereference)
*p; - раскодирует то, что лежит по адресу

&: T -> T*

Указатель обычно выводится в 16-ти ричной системе. 

+: (T*, int) -> T*
   (int, T*) -> T*
+= ++ -- -=

-: (T*, T*) -> ptrdif_t(=int)

К числу нельзя добавить указатель, так как это буессмысленная операция.
Нельзя складывать два указатель, но вычитать можно.

void* - указатель на нечто определенное. Указатель на память, где непонятно что лежит. 

nullptr; - аналог нуля в мире указателей. Тип nullptr_t приводится к любому типу.

Разыменовая указателья под которым лежит непонятно что будет ub.















